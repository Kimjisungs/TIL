this 미래에 생성할 인스턴스 객체를 가르킨다.

자신이 생성한 인스턴스의 부모역할을 할 프로토타입을 가르킨다. 

person생성자함수는 객체의 인스턴스를 만드는 것이 존재목적이다.  

상속이 없는 객체지향은 없는것과 같다.

자바스크립트 엔진이 파싱을하여 자료구조를 만든다. 객체지향

## 객체지향

객체 지향은 object라고하고 이 반대는 subject이다.  내가 대상화하는것을 객체라고함. 생각하고 판단할 수 있는 모든 대상을 객체라고 판단. 행위는 상태와 관련이있다. 메소드는 상태와 관련이있다. 객체들은 서로 관계를 맺는다. 

클래스나 생성자가 단독으로 있을때는 상관이 없지만, new를 햇을때 그속성을 가지고있는 객체들이 튀어나온다.

인스턴스가 생성되면 그 부모가 누가 되면 프로토 타입이 된다.

그 부모는 내가 결정하는게 아니라 태어날 때 결정되어있다. 생성자 함수에 의해서.

Person이라는 생성자 함수를 생성하고, 클래스 기반의 클래스와 동일, 찍어내는 작업을 new라고해서 객체의 생성이라고 함. 그래서 튀어나온 결과물이 instance이다. 상태만 다르고 고주는 같다. 이것이 객체 지향의 전반적인 개념이다.  부자간에는 상호작용이며, 형제간에도 상호작용을 할 수있다. 부자간에는 부탁을 안해도 가져다 사용할 수 있다. 상속이라는메카니즘을 프로토타입이라고 한다.

이름, 주소 라는 관심있는것만 나열하는것을 **추상화** 라고한다. 

객체는 만들기전에 설계해야한다. 설계서가 class 또는 생성자 함수이다. 

생성자함수에서 프로퍼티는 상태마다 다르니까 각각이 가지고 있는게 맞는데, 메소드는 개별적으로 가지고 있을 필요가 없다. 이러한 중복을 안되게 하기위해 아버지에게 메소드를 준다.

상속은 중복제거의 이유이다.

생성자 함수는 프로토타입이라는 프로퍼티를 가지고 있다. 그 프로토타입이라는 프로퍼티는 함수만 가지고있다. constuctor = normal함수만 가지고 있다.  생성자함수는 constuctor와 프로토타입까지 만들어준다. 

cicle1을 먼저 찾고 프로토타입 체인에 의해 __proto__ 접근자 프로퍼티를 타고 프로토 타입을 찾는다. getter를 돌린다. 할당을하게되면 __proto__의 setter가 돈다. 

자바스크립트 메카니즘은 찾을때 프로토타입 체인은 식별자, 참조한 코드가 있는 지역에서부터 찾는다. object.prototype이 __proto__를 가지고 있다. 모든 프로토타입 객체에는 컨스트럴쳐가 있는데 이 constuctor는 생성자 함수를 가르킨다.  

생성자함수는 인스턴스를 찾을 수없다. 단방향 링크드여서.  

프로토타입체인은 단방향 링크드, 객체인스턴스의 프로퍼티를 탐색하는 메커니즘을 말한다. 

메소드는 인스턴스메소드, 정적메소드 , 프로토타입 메소드

정적메소드는 인스턴스 생성과정이 없어도 호출할 수잇다.

정적,프로토타입 메소드는 호출할 수 없다. 

__ proto __ 는 [[prototype]] 내부 슬롯에 접근할 수 있다. 비표준이었었다. ecma es6로올라갈때 표준화 하였다. 사용하지 않기를 권장한다. 메소드를 사용하기를 권장하는데 그것은 

Object.getPrototypeOf(circle) === Circle.prototype으로 사용해라

객체 리터럴은 createObject라는 추상연산이 만든다. 빈객체를 만들고 빈객체에다가 프로퍼티를 추가한다. objectcreate가 쓰는 추상연산이 

함수도 createFunction 이 만듬. 

정적 메소와 프로토타입 메소드를 알아야함.

정적 메소드는 생성자 함수가 가지고 있는 프로퍼티 , 링크가 깨졌다. 



함수객체는 함수객체가 function.protytype.

배열의 프로토타입은 array.prototype

데이트객체의 프로토타입은 date.prototype

date.prototype의 부모는 Object.prototype
Object.prototype의 종점은 null이다.

Object.prototype은 모두가 다 쓸 수 있다.



## 객체의 캡슐화

공개할 프로퍼티와 공개하지 않을 프로퍼티를 나누겠다. (정보 은폐);
객체의 정보 : 프로퍼티, 상태를 혹은 메소드를 공개를 할것인가 말것인가.



**클래스 기반언어** : 퍼블릭:다른객체들도,프라이베잇:내부에서만,프로텍티드:상속관계에서만 라는 접근 제한자





함수가 호출되면 살아나고 끝나면 죽는다 . 생명주기의 스코프,

Person.prototype의 객체는 죽지 않았기 때문에. 

~~~javascript
const Person = (function () { //실행되면 아래가 생성, person.protytpe.도생성 그러면 sayHello가생성
  // 자유 변수이며 private하다
  let _name = ''; //렉시컬스코프에 의해서 함수들의 상위 스코프가 변수를 기억한다. 

  // 생성자 함수
  function Person(name) { _name = name; }

  // 프로토타입 메소드
  Person.prototype.sayHello = function () {
    console.log(`Hi! My name is ${_name}`);
  };

  // 생성자 함수를 반환
  return Person;
}());

const me = new Person('Lee');
me.sayHello();
~~~

모든 함수는 자신이 생성될때 상위 스코프를 기억한다. 

정의되었을때 를 기점으로 , 이것이 렉시컬 스코프;

죽지만 자신의 상위 스코프를 기억한다. 

모든 함수가 [[Envaiorment]] 상위 스코프를 기억한다.  변수, 함수, 매개변수

프라이빗한 변수는 클로져로서 정보를 은폐할 수 있다. 





쉐도잉.

.call() // 첫번째 인수는 콜앞에있는 아이들을 this를 첫번째 인자로 써라. 인수는 두번째,  콤마로 이어붙힌다.

apply() 두번쨰 인수는 배열이다. 

bind()는 this만 주고 호출하지앟는다. 



정적메소드는 아무대나사용. object.Create()같은.

프로토타입, 인스턴스 메소드는 인스턴스 객체가 있어야 사용

person 이 있나 없나. 확인은 '프로퍼티' in person

in연산자는 상속 받을게 있는 모든 연산자를 다 돈다. ex toString도 돈다.

내가 가지고 있는 것만 보고 싶다. person.hasOwnProperty('name'); // true;

객체의 프로퍼티를 열거, 나열, 순회 하는 방법은 

for (in) for in은 사용하면 안좋다

for of 이것은 이터러블을 알아야한다. 

for (const )사용이 가능한것은 const가 새로 만들어짐.



### Object.keys/value/entries

keys. 키값을 배열에담음

value 값을 배열에 담음

entries는 둘다 배열에 담음.



object.prototype.hasOwnpropoerty.call()

## 전역객체

javascript 엔진이 만드는것. 브라우져가 생기자마자, 가동되자마자. 표준 빌트인객체가 가지고 있다. 환경에 따라서 독특한 api를 추가적으로 같는다. 브라우져 환경이라면 dom,bom,fatch등 node는 http, filesystem등을 가지고 있다. 전역객체는 이런것들을 모두 가지고 있다. 브라우져를 닫지 않으면 죽지않음. 브라우져 환경에서 전역객체는 window다.  window === self  

var 키워드는 윈도우와 생명주기가 같다. const와 let 전역 렉시컬 환경에 선언적 환경 레코드에 들어있다. 

인스턴스와 상관없이 범용적으로 사용되는것들.

예제는 항상 쳐봐야한다.

## this

프로퍼티나 메소드를 참조하기위해 this를 사용한다. 일반 함수인지 생성자함수인지 구분할 수없다. this는 객체와 관련이있고, 가르키는것은 객체를 가르킨다. 일반함수내에서 this를 가르킬 일이없기 때문에 필요없다. 

화살표함수는 this를 가지고있지 않다.

우리마음대로 바꿀수 있다.  call, apply, bind



this

foo(); 일반함수호출 // 전역객체

new foo(); 생성자 함수호출 // 인스턴스 객체

o.foo(); 객체 호출 // 메소드를 호출한 객체. object.protype의 메소드를 실행해도 호출한 객체가 this이다

foo.call(x); 간접호출 // 이것은 별도.

콜백함수는 고차함수 마음

함수의 정의 방식과 호출 방식은 일치하지 않는다. 

함수정의방식으로 정의하지않고 어떻게 호출하느냐에 따라 this를 동적으로 결정한다.  

바인딩. 식별자와 값을 바인딩하는것.

this바인딩은 this가 식별자이다. this로 값이 평가된다. 식별자의 특징을 지닌 키워드이다. 

this는 어디에서도 참조할 수있다. this는 생성자함수, 메소드는 프로퍼티를 참조한다. 메소드 안에서 this를 사용하지 않으면 eslint에서 빨간줄이 된다. this안쓸거면 정적 메소드로 해라.  정적메소드들은 라이브러리이다. ? 



렉시컬스코프는 함수의 상위 스코프를 결정하는것. 이것은 정적이다. 함수의 정의가 여기갔다 저기갔다가 하지 않는다. this는 값이 동적으로 변환된다. 함수 호출에 따라서 .

일반함수는 무조건 전역객체. 호출 방식에 따라서!! 

바인드는 식별자 값을 묶는다. 함수가 가지고있는 this를 그객체 this에 바인딩해라. 

call/ apply/ bind는 function.prototype에 소속되어있다.

call, apply차이는 두번째 인수를 어떻게 주느냐 .

apply(thisArg,[인수,인수,인수]); 내부에서 아규먼트객체를 볼것이다

call(thisArg,인수,인수,인수) 내부에서 아규먼트객체를 볼것이다

첫번째로 전달한 객체를 this로 사용하게 끔한다. 

데이터를 어떻게 가지고 있냐의 따라, 배열로가지고잇으면 apply,

동적으로생성되는거면 call

slice라는 함수는 배열 객체. 프로토타입 체인이 다름. 

유사배열객체를 배열로 컨버전 하고싶다. 